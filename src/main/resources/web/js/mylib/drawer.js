// Generated by CoffeeScript 1.12.2

/*
@author Lhfcws
Drawer wrapper of ECharts

use CoffeeScript to implements OOP as ES6 is not supported by most of the browsers in this time.
 */

/*
  画图入口类，draw为静态调用方法，调用姿势 Drawer.draw(htmlId, option, title)
 */
var BarOption, Drawer, LineOption, LineOptions, Option, PieOption, StackBarOption, TableOption,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Drawer = (function() {
  function Drawer() {}

  Drawer.draw = function(htmlId, option, title) {
    var app;
    app = echarts.init(document.getElementById(htmlId));
    app.title = title;
    return app.setOption(option);
  };

  Drawer.drawTable = function(htmlId, tableHtml) {
    return $("#" + htmlId).append(tableHtml);
  };

  return Drawer;

})();

Option = (function() {
  function Option(name, type, xdata, ydata) {
    this.name = name;
    this.type = type;
    this.xdata = xdata;
    this.ydata = ydata;
    this.otherSettings = {};
  }

  Option.prototype.setOtherSettings = function(o) {
    this.otherSettings = o;
    return this;
  };

  Option.prototype._init = function() {};

  Option.prototype.formatData = function() {
    return this.ydata;
  };

  Option.prototype.template = function() {
    return {};
  };

  return Option;

})();

TableOption = (function(superClass) {
  extend(TableOption, superClass);

  function TableOption(title1, hasHeader, data) {
    this.title = title1;
    this.hasHeader = hasHeader;
    this.data = data;
    TableOption.__super__.constructor.call(this, this.title, "table", [], []);
  }

  TableOption.prototype.template = function() {
    var d, html, i, item, j, l, len, len1, m, n, ref, ref1, start;
    html = [];
    start = 0;
    if (this.hasHeader) {
      start = 1;
      d = this.data[0];
      l = [];
      for (j = 0, len = d.length; j < len; j++) {
        item = d[j];
        l.push("<th>" + item + "</th>");
      }
      html.push("<tr>" + (l.join(" ")) + "</tr>");
    }
    for (i = m = ref = start, ref1 = this.data.length; ref <= ref1 ? m < ref1 : m > ref1; i = ref <= ref1 ? ++m : --m) {
      d = this.data[i];
      l = [];
      for (n = 0, len1 = d.length; n < len1; n++) {
        item = d[n];
        l.push("<td>" + item + "</td>");
      }
      html.push("<tr>" + (l.join(" ")) + "</tr>");
    }
    return "<h5>" + this.title + "</h5><table class='table'>" + (html.join(" ")) + "</table>";
  };

  return TableOption;

})(Option);


/*
  折线图/散点图配置
 */

LineOption = (function(superClass) {
  extend(LineOption, superClass);

  function LineOption() {
    return LineOption.__super__.constructor.apply(this, arguments);
  }

  LineOption.prototype._init = function() {
    this.color = "blue";
    return this.fillArea = false;
  };

  LineOption.prototype.formatData = function() {
    var i, j, ref, ret;
    ret = [];
    for (i = j = 0, ref = this.xdata.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      ret.push([this.xdata[i], this.ydata[i]]);
    }
    return ret;
  };

  LineOption.prototype.template = function() {
    var areaIfConfigured;
    areaIfConfigured = "";
    if (this.fillArea) {
      areaIfConfigured = {
        areaStyle: {
          normal: {
            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
              {
                offset: 0,
                color: 'rgb(255, 255, 255)'
              }, {
                offset: 1,
                color: '#{this.color}'
              }
            ])
          }
        }
      };
    }
    if (this.type === "line") {
      return Util.mergeObject({
        name: this.name,
        type: this.type,
        smooth: true,
        itemStyle: {
          normal: {
            color: this.color
          }
        },
        data: this.formatData()
      }, areaIfConfigured, this.otherSettings);
    } else if (this.type === "scatter") {
      return Util.mergeObject({
        name: this.name,
        type: this.type,
        itemStyle: {
          normal: {
            color: this.color
          }
        },
        data: this.formatData()
      }, areaIfConfigured, this.otherSettings);
    }
  };

  return LineOption;

})(Option);

LineOptions = (function() {
  function LineOptions(isTimeXAxis) {
    this.isTimeXAxis = isTimeXAxis;
    this.options = [];
  }

  LineOptions.prototype.addOption = function(option) {
    return this.options.push(option);
  };

  LineOptions.prototype.template = function() {
    var j, len, len1, m, names, oh, option, ref, ref1, xAxis;
    names = [];
    ref = this.options;
    for (j = 0, len = ref.length; j < len; j++) {
      option = ref[j];
      names.push(option.name);
    }
    oh = [];
    ref1 = this.options;
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      option = ref1[m];
      oh.push(option.template());
    }
    if (oh.length === 0) {
      return {};
    }
    xAxis = {
      xAxis: {
        type: 'category',
        boundaryGap: false,
        data: this.options[0].xdata
      }
    };
    if (this.isTimeXAxis) {
      xAxis = {
        xAxis: {
          type: 'time',
          splitLine: {
            show: false
          }
        }
      };
    }
    return Util.mergeObject(xAxis, {
      yAxis: {
        type: 'value',
        splitLine: {
          show: false
        }
      },
      legend: {
        data: names
      },
      series: oh
    });
  };

  return LineOptions;

})();


/*
  StackBar
 */

StackBarOption = (function(superClass) {
  extend(StackBarOption, superClass);

  function StackBarOption(name, xdata, ydata, yAxisLabels) {
    this.name = name;
    this.xdata = xdata;
    this.ydata = ydata;
    this.yAxisLabels = yAxisLabels;
    StackBarOption.__super__.constructor.call(this, this.name, "bar", this.xdata, this.ydata);
  }

  StackBarOption.extractFromObject = function(obj) {
    var k, key, o, obj0, ref, v, xd, ya, yd;
    ya = [];
    o = {};
    for (key in obj) {
      obj0 = obj[key];
      ya.push(key);
      for (k in obj0) {
        v = obj0[k];
        if (o[k] === void 0) {
          o[k] = [];
        }
        o[k].push(v);
      }
    }
    ref = Util.mapToXYData(o), xd = ref[0], yd = ref[1];
    return [xd, yd, ya];
  };

  StackBarOption.prototype.setYAxisLabels = function(yLabels) {
    return this.yAxisLabels = yLabels;
  };

  StackBarOption.prototype.template = function() {
    var ret;
    ret = Util.mergeObject({
      tooltip: {
        trigger: 'axis',
        axisPointer: {
          type: 'shadow'
        }
      },
      legend: {
        data: this.xdata
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
      },
      xAxis: {
        type: 'value'
      },
      yAxis: {
        type: 'category',
        data: this.yAxisLabels
      },
      series: this.formatData()
    }, this.otherSettings);
    return ret;
  };

  StackBarOption.prototype.formatData = function() {
    var i, j, ref, ret;
    ret = [];
    for (i = j = 0, ref = this.xdata.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      ret.push({
        name: this.xdata[i],
        type: 'bar',
        stack: '总量',
        label: {
          normal: {
            show: true,
            position: 'insideRight'
          }
        },
        data: this.ydata[i]
      });
    }
    return ret;
  };

  return StackBarOption;

})(Option);


/*
  Simple Bar
 */

BarOption = (function(superClass) {
  extend(BarOption, superClass);

  function BarOption() {
    return BarOption.__super__.constructor.apply(this, arguments);
  }

  BarOption.prototype.template = function() {
    return Util.mergeObject({
      grid: {
        left: '20%'
      },
      yAxis: [
        {
          type: 'category',
          data: this.xdata,
          axisTick: {
            alignWithLabel: true
          }
        }
      ],
      xAxis: [
        {
          type: 'value'
        }
      ],
      series: [
        {
          name: this.name,
          type: 'bar',
          label: {
            normal: {
              show: true,
              position: 'right'
            }
          },
          itemStyle: {
            normal: {
              color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                {
                  offset: 0,
                  color: '#83bff6'
                }, {
                  offset: 0.5,
                  color: '#188df0'
                }, {
                  offset: 1,
                  color: '#188df0'
                }
              ])
            },
            emphasis: {
              color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                {
                  offset: 0,
                  color: '#2378f7'
                }, {
                  offset: 0.7,
                  color: '#2378f7'
                }, {
                  offset: 1,
                  color: '#83bff6'
                }
              ])
            }
          },
          barWidth: '60%',
          data: this.ydata
        }
      ]
    }, this.otherSettings);
  };

  return BarOption;

})(Option);


/*
  饼图配置
 */

PieOption = (function(superClass) {
  extend(PieOption, superClass);

  function PieOption() {
    return PieOption.__super__.constructor.apply(this, arguments);
  }

  PieOption.prototype.formatData = function() {
    var i, j, ref, ret;
    ret = [];
    for (i = j = 0, ref = this.xdata.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      ret.push({
        name: this.xdata[i],
        value: this.ydata[i]
      });
    }
    ret = ret.sort(function(o1, o2) {
      return o1.value < o2.value;
    });
    return ret;
  };

  PieOption.prototype.template = function() {
    var ret;
    ret = Util.mergeObject({
      tooltip: {
        trigger: 'item',
        formatter: "{b}: {c} ({d}%)"
      },
      series: [
        {
          name: this.name,
          type: this.type,
          label: {
            normal: {
              formatter: '{b}\n{d}%'
            }
          },
          markLine: {
            label: {
              normal: {
                position: "start"
              }
            }
          },
          radius: ['50%', '80%'],
          data: this.formatData()
        }
      ]
    }, this.otherSettings);
    return ret;
  };

  return PieOption;

})(Option);
